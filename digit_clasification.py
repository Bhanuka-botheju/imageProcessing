# -*- coding: utf-8 -*-
"""Digit Clasification

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1c5uK7hAeCpPHgXl_88o8jvrRvqtLj7_o

# **Image Preprocessing**
"""

# GETTING IMAGE USING WEBGET COMMAND
!wget "https://i.pinimg.com/1200x/1e/05/c7/1e05c70d05a867527a95a41c36b6e6a8.jpg"

"""**Libraries that can be used in image processing**

1. matplotlib.image
2. pillow
3. openCV (computer vision)
"""

# IMPORT MATPLOTLIB LIBRARIE FOR IMAGE PROCESS
import matplotlib.image as mpimg
import matplotlib.pyplot as plt

img = mpimg.imread("Lional_Messi.jpg")
type(img)

img.shape  # height , width , channel count (1 channel / 3 channel)

#print(img)

# CONVERT NUMPY.ARRAY TO IMAGE
img_plot = plt.imshow(img)

from PIL import Image

"""type(img)"""

img = Image.open("Lional_Messi.jpg")
img_resize = img.resize((200,400))   # RESIZE THE IMGE (WIDTH,HEIGHT)
print(plt.imshow(img_resize))

img_resize.save("Lional_Messi_resized.jpg")

"""CONVERTING RGB IMAGE TO GRAYSCALE IMAGE

- USING OPENCV

"""

import cv2

img = cv2.imread("Lional_Messi.jpg")
type(img)
print(img.shape)

gray_img = cv2.cvtColor(img,cv2.COLOR_RGB2GRAY)
print(gray_img.shape)

print(plt.imshow(gray_img))

from google.colab.patches import cv2_imshow

cv2_imshow(gray_img)

cv2.imwrite("Lional_Messi_gray.jpg",gray_img)

"""# **Digit Classification**"""

#IMPORT DEPENDENCIES

import numpy as np               #Maths & Arrays
import matplotlib.pyplot as plt  #Visualitation
import seaborn as sns
import cv2                       # Image Handleling
from google.colab.patches import cv2_imshow
from PIL import Image       #Image file manipulation
import tensorflow as tf    # deep leaning framework
tf.random.set_seed(3)       #random number generate
from tensorflow import keras
from keras.datasets import mnist   # dataset in available in keras libraries
from tensorflow.math import confusion_matrix

# LOADING MNIST DATA

keras.datasets.mnist.load_data(path="mnist.npz")

(x_train , y_train),(x_test,y_test) = mnist.load_data()

print(x_train.shape,y_train.shape ,x_test.shape ,y_test.shape)

"""**little bit about dataset**
- all are grayscale images
- all in numpy.array format
- resolution 28*28
- train - 60,000 images
- test - 10,000 images
"""

print(x_train[9])

print(x_train[9].shape)

print("This is a image ",plt.imshow(x_train[10]))
print("This is a target",y_train[10])

# TARGET VALUES

print(np.unique(y_train),np.unique(y_test))

# SCALING THE VALUES - NORMALIZATION

x_train = x_train/255
x_test = x_test/255

print(x_train[9])

# print(x_train.shape,y_train.shape)

# x_test = x_test*255
# y_test = y_test*255
# print(y_train[:10])

model = keras.Sequential([
    keras.layers.Flatten(input_shape=(28,28)),
    keras.layers.Dense(128, activation='relu'),
    keras.layers.Dense(128, activation='relu'),
    keras.layers.Dense(10, activation='softmax')  # FIXED
])

# COMPILING THE NUERAL NETWORK

model.compile(optimizer='adam',
              loss='sparse_categorical_crossentropy',  # correct for integer labels
              metrics=['accuracy'])

# TRAINNIG NETWORK

model.fit(x_train,y_train,epochs=10)

loss , accuracy = model.evaluate(x_test,y_test)
print(accuracy)

y_pred = model.predict(x_test)
print(y_pred[0])

"""model.prdict() give us probability of above 10 classes"""

label_for_first_image = np.argmax(y_pred[0])
print(label_for_first_image)
print(y_test[0])

# CONVERT PREDICTION PROBABILITY TO CLASS LABEL

y_pred_labels = [np.argmax(i) for i in y_pred]
print(y_pred_labels)

con_matrix = confusion_matrix(y_test , y_pred_labels)
print(con_matrix)

plt.figure(figsize=(15,7))
sns.heatmap(con_matrix,annot=True,fmt='d',cmap='Blues')
plt.ylabel('True label')
plt.xlabel('Predicted label')

"""this heatmap think like this
- get (0,0) cell
951 - mean's we get correctly 951 times
- get (0,1) cell
0 -mean's we grt nothing wrong as a 1

**Building a Predictive system**
"""

# from google.colab.patches import cv2_imshow

input_image_path = 'final-image.jpg'

input_img = cv2.imread(input_image_path)
type(input_img)
print(input_img.shape)

img_gray = cv2.cvtColor(input_img, cv2.COLOR_BGR2GRAY)
img_resized = cv2.resize(img_gray, (28, 28))
cv2_imshow(img_resized)
print(img_resized.shape)

img_array = img_resized/255
img = np.reshape(img_array,[1,28,28])


prediction = model.predict(img)
print("this is a predict: " , np.argmax(prediction))

